syntax = "proto3";
package relay;

// Basic key/value pair used to store header data.
message Header {
  string name = 1;
  string value = 2;
}

// Entry is an individual piece of structured data provided by wallet authors.
message ProfileEntry {
  // Kind is a hint to wallets as to what type of data to deserialize from the
  // metadata field.
  string kind = 1;
  // The headers is excess metadata that may be useful to a wallet.
  repeated Header headers = 2;
  // Body of the metadata field.
  bytes entry_data = 3;
}

// A profile attached to an address.
message Profile {
  // Timestamp allows servers to determine which version of the data is the most
  // recent. Given in milliseconds.
  int64 timestamp = 1;
  // TTL tells us how long this profile should exist before being considered
  // invalid. Given in milliseconds.
  int64 ttl = 2;
  // User specified data.  Presumably some conventional data determined by
  // wallet authors.
  repeated ProfileEntry entries = 3;
}

// Entry is an individual piece of structured data.
message Entry {
  // Informs the wallet what to do with this payload.
  string kind = 1;
  // The headers provide some extra metadata about the field that
  // may be relevant to the wallet.  At this time there are no meaningful
  // headers.
  repeated Header headers = 2;
  // Body of the metadata field.
  bytes entry_data = 3;
}

// Payload is the user-specified data section of the message that is
// encrypted by the shared secret.
message Payload {
  // Timestamp provided by sender.
  int64 timestamp = 1;
  // The entries, containing body of the payload.
  repeated Entry entries = 2;
}

// A stamp transaction paired with a list of vouts identifying to stamp outputs.
message StampOutpoints {
  // A serialized stamp transaction.
  bytes stamp_tx = 1;
  // The specified outputs of the stamp transaction.
  repeated uint32 vouts = 2;
}

// Represents a stamp. This is attached to Message in order to attach value.
message Stamp {
  // Represents the stamp type.
  enum StampType {
    None = 0;
    // Hash commitment means the stamp is being sent to the address specified by
    // public keys of the xpub defined by:
    // PublicKey: dG + SHA256(payload)G
    // ChainCode: SHA256(payload)
    MessageCommitment = 1;
  }
  // The stamp type.
  StampType stamp_type = 1;
  // A collection of stamp outpoints.
  repeated StampOutpoints stamp_outpoints = 2;
}

// The primary message used in communication over the cashweb protocol.
message Message {
  // The senders serialized public key.
  bytes source_public_key = 1;
  // The destinations serialized public key.
  bytes destination_public_key = 2;
  // Maleable server time. This field is optional.
  int64 received_time = 3;
  // The SHA-256 digest of the payload. This is independent of the MAC
  // as only the sender/receiver can verify MAC.
  //
  // The relay server may set this field if it strips the payload from the
  // message it sends to the client over websockets. In which case the
  // payload would be available over the payloads API.
  bytes payload_digest = 4;
  // The stamp attached to the message.
  Stamp stamp = 5;
  // Represents an encryption scheme.
  enum EncryptionScheme {
    // Indicates the payload is unencrypted.
    None = 0;
    // For EphemeralDH, ECDH is used to generate a shared secret based on the
    // combination of the source and destination pubkeys. The shared secret is
    // the ECDH combination of the source and destination keys, 
    // S = HMAC(sdG, salt)

    // The payload is encrypted with AES128 CBC with key given by the first 16
    // bytes of S and the IV given by the last 16 bytes of S.
    EphemeralDH = 1;
  }
  // The encryption scheme used on the payload.
  EncryptionScheme scheme = 6;
  // This salt is added to the HMAC to provide a shared source of entropy
  // (e.g. the Chaincode for stamp outputs: SHA256(chaincode))
  // but also to provide the sender a way to add a commitment to any additional
  // data they may want to prove they had later.
  //
  // One such example would be a commitment to their private key, so that
  // they can prove they sent the message. This may be important since some
  // wallets may want to increment internal state with each message they send --
  // and this provides a way to do so that is strong against forgery.
  bytes salt = 7;
  // The HMAC of the payload using the shared key, HMAC(HMAC(ser(sdG), salt), payload_digest)
  bytes payload_hmac = 8;
  // Optional size, which may be set by the relay server. This enables the
  // client to deside if they want to download the payload based on the stamp
  // value.
  uint64 payload_size = 9;
  // The serialized and encrypted payload and covered by the HMAC.
  //
  // This field may be stripped by a relay server if it is large. In which
  // case it will be made available at the payloads endpoint via the digest.
  // If the payload is not set, the payload digest becomes a mandatory field.
  bytes payload = 100;
}

// Collection of messages. Pushed from client to server via HTTP.
message MessageSet { repeated Message messages = 1; }

// An error associated with the validation and insertion of a message.
message PushError {
  // Status code of the error.
  uint32 status_code = 1;
  // Textual information of the error.
  string error_text = 2;
}

// A collection of errors yeilded when pushing message to the server.
message PushErrors {
  // A map of errors, keyed by the index of the failed message.
  map<int32, PushError> errors = 1;
}

// A page of messages. Pulled from server via HTTP.
message MessagePage {
  // Collection of messages.
  repeated Message messages = 1;
  // The received time of the earliest message in the page.
  int64 start_time = 2;
  // The received time of the latest message in the page.
  int64 end_time = 3;
  // The payload digest of the earliest message in the page.
  bytes start_digest = 4;
  // The payload digest of the latest message in the page.
  bytes end_digest = 5;
}

// A page of payloads. Pulled from server via HTTP.
message PayloadPage {
  // Collection of payloads.
  repeated bytes payloads = 1;
  // The received time of the earliest payload in the page.
  int64 start_time = 2;
  // The received time of the latest payload in the page.
  int64 end_time = 3;
  // The payload digest of the earliest payload in the page.
  bytes start_digest = 4;
  // The payload digest of the latest payload in the page.
  bytes end_digest = 5;
}
